<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>GRAYCODE JavaScript</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            font-size: 14px;
        }
        body {
            position: relative;
        }
        h1 {
            height: 50px;
            margin: 0 1em;
            padding: 0;
            text-align: center;
            font-size: 2em;
        }
        #parent {
            left: 0;
            top: 0;
            position: relative;
            margin: auto;
            height: calc(100% - 50px);
            width: 100%;
            overflow: hidden;
            background-color: #3f98d1;
        }
        #stage {
            position: absolute;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
        /*    border-radius: 75px;*/
            background-color: #cadf14;
        }
        .imageContainer {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #ic0 {
            background-color: #df149b;
            left: 0;
            top: 0;
            z-index: 1;
        }
        #ic1 {
            background-color: #dfba14;
            left: 0;
            top: 0;
            z-index: 0;
        }
        .imageContainer img {
            position: absolute;
            left: 50%;
            top: 50%;
            width: auto;
            height: auto;
            max-width: 100vh;
            max-height: 100vw;
            /*margin: auto;*/
            transform: translate(-50%, -50%) rotate(90deg);
            /*scale: calc(4 / 3);*/
        }

    </style>
</head>
<body>
    <h1>スマホでスワイプ</h1>
    <section id="parent">
        <div id="stage">
            <div id="ic0" class="imageContainer"><img alt="写真" /></div>
            <div id="ic1" class="imageContainer"><img alt="写真" /></div>
        </div>
    </section>

    <script>
        const THRESHOLD = 3;
        // HTML要素関連変数
        let _elm = {
            parent: document.getElementById("parent"),  // #parent要素
            stage: document.getElementById("stage"),    // #stage要素
            images: [document.getElementById("ic0"), document.getElementById("ic1")],
            parentRect: null
        };
        _elm.parentRect = _elm.parent.getBoundingClientRect();
        
        // status管理関連変数
        let _status = {
            isTouching: false,  // touchstart しているか
            isSwiping: false,   // スワイプしているか
            isAnimating: false, // 移動アニメーション中か
            swipeDirection: undefined,
            nextImagePlace: undefined   // 0, 1, 2, 3
        };

        // 写真関連変数
        let _photo = {
            BASEURL: "./img/",
            BASEYEAR: 2019,
            year: 2021,
            chonai: 9
            //infoFile: "photo.js"
        }

        let _touchStartPos = {x: null, y: null};
        let _touchEndPos = {x: null, y: null};
        let _touchPos = {x: null, y: null};   // タッチされた時点におけるタッチのstageからの相対座標
        let _currentImageIdx = 0;   // 現在表示されているimage要素を示す (#ic0 / #ic1)
        let _startStagePos = {x: null, y: null}; // touchstart時のstage要素の座標
        let _baseStagePos = {x: null, y: null};  // 基準となるstageの座標（アニメーションの終了位置を求めるのに使用） 
        let _timerId = undefined;    // animationのsetInterval()が返すタイマーID

        let _image = {width: 0, height: 0};
        {
            // imageBoxのwidth, heightを_imageオブジェクトに保存
            let bound = _elm.images[0].getBoundingClientRect();
            _image = {width: bound.width, height: bound.height};
        }

        // 写真の初期表示
        _elm.images[_currentImageIdx].getElementsByTagName("img")[0].setAttribute("src", getPhotoURL(_photo.year, 8));
        
        // タッチ開始
        _elm.stage.addEventListener('touchstart', onSwipeStart);
        // スワイプ／フリック
        _elm.stage.addEventListener('touchmove', onSwipe);
        // タッチ終了
        _elm.stage.addEventListener('touchend', onSwipeEnd);




        function onSwipeStart(event) {
            //event.preventDefault();

            _startStagePos = getRelPos(_elm.stage, _elm.parent);     // stage要素の親要素からの相対座標を保存
            let bounding = _elm.stage.getBoundingClientRect();
            _touchPos = {x: event.touches[0].clientX - bounding.left, y: event.touches[0].clientY - bounding.top}; // stage相対座標

            if (_status.isAnimating) {
                clearInterval(_timerId);    // animationを止める
                _status.isAnimating = false;
                _status.isSwiping = true;
            }
            else {
                _baseStagePos = _startStagePos;
            }
            _status.isTouching = true;
            _touchStartPos = {clientX: event.touches[0].clientX, clientY: event.touches[0].clientY};    // 座標系はなんでもいい
        }



        function onSwipe(event) {
            if (! _status.isTouching)
                return;

            // event.preventDefault();

            // スワイプ開始の判定
            // 　touch直後は不安定なので、スワイプの方向の判定は指の移動距離が閾値を超えた時に行う。
            {
                if (_status.isSwiping == false) {
                    let deltaX = event.touches[0].clientX - _touchStartPos.clientX;
                    let deltaY = event.touches[0].clientY - _touchStartPos.clientY;
                    // 閾値を超えたらスワイプの方向を判定する。
                    if (Math.max(Math.abs(deltaX), Math.abs(deltaY)) < THRESHOLD)
                        return;

                    if (Math.abs(deltaX) >= Math.abs(deltaY)) {
                        _status.swipeDirection = deltaX >= 0 ? 1 : 3;
                    }
                    else {
                        _status.swipeDirection = deltaY >= 0 ? 2 : 0;
                    }
                    _status.isSwiping = true;
                }
            }


            // stage要素をスワイプで移動
            // 　stageを移動することで配下の2つのimageBoxを移動させる。
            {
                if (_status.swipeDirection == 1 || _status.swipeDirection == 3) {
                    //_elm.stage.style.left = _startStagePos.x + (event.touches[0].clientX - _touchStartPos.clientX) + "px";
                    _elm.stage.style.left = event.touches[0].clientX - _touchPos.x - _elm.parentRect.left + "px";
                }
                else {
                    //_elm.stage.style.top  = _startStagePos.y + (event.touches[0].clientY - _touchStartPos.clientY) + "px";
                    _elm.stage.style.top  = event.touches[0].clientY - _touchPos.y - _elm.parentRect.top + "px";
                }
            }


            // imageBoxの移動によってスキマのできる側が変わった時、次の画像のimageBoxを再配置
            {
                let imagePos = getRelPos(_elm.images[_currentImageIdx], _elm.parent);

                if (_status.swipeDirection == 1 || _status.swipeDirection == 3) {
                    if (imagePos.x >= 0) {  // 右側にスワイプされていて
                        if (_status.nextImagePlace != 3) {  // 次のimageBoxが左側にないなら
                            replaceNextImage(3);            // 左側に移動させる
                            _status.swipeDirection = 1;     // スワイプの方向を右側にする
                        }
                    }
                    else {
                        if (_status.nextImagePlace != 1) {
                           replaceNextImage(1);
                           _status.swipeDirection = 3;
                        }
                    }
                }
                else {
                    if (imagePos.y >= 0) {
                        if (_status.nextImagePlace != 0) {
                            replaceNextImage(0);
                            _status.swipeDirection = 2;
                        }
                    }
                    else {
                        if (_status.nextImagePlace != 2) {
                            replaceNextImage(2);
                            _status.swipeDirection = 0;
                        }
                    }
                }
            }
        }



        function onSwipeEnd(event) {
            // event.preventDefault();
            _status.isTouching = false;
            _status.isSwiping = false;
            animateStage(_status.swipeDirection);
        }



        // stageをスワイプした事でできたスキマを埋めるようにもう一つのイメージBoxを移動
        function replaceNextImage(place) {
            let currentImageElm = _elm.images[_currentImageIdx];
            let nextImageElm = _elm.images[Math.abs(_currentImageIdx - 1)];

            let currentImagePos = getRelPos(currentImageElm, _elm.stage);   // stage座標

            switch (place) {
                case 0:
                    nextImageElm.style.top =  (currentImagePos.y - _image.height) + "px";
                    nextImageElm.style.left = (currentImagePos.x) + "px";
                    break;
                case 1:
                    nextImageElm.style.top =  (currentImagePos.y) + "px";
                    nextImageElm.style.left = (currentImagePos.x + _image.width) + "px";
                    break;
                case 2:
                    nextImageElm.style.top =  (currentImagePos.y + _image.height) + "px";
                    nextImageElm.style.left = (currentImagePos.x) + "px";
                    break;
                case 3:
                    nextImageElm.style.top =  (currentImagePos.y) + "px";
                    nextImageElm.style.left = (currentImagePos.x - _image.width) + "px";
                    break;
            }
            _status.nextImagePlace = place;

            currentImageElm.style.zIndex = 0;
            nextImageElm.style.zIndex = 10;
        }



        /**
         * touchend（指が離れて）から、次の画像が定位置に来るようにstageをアニメーション移動する。
        */
        function animateStage(direction) {
            _status.isAnimating = true;

            console.log("animateStage(" + direction + ")");
            
            // スワイプ前のstage座標(_baseStagePos)と、directionからstageの終点座標を求める。
            let newStageXY;

            switch (direction) {
                case 0:
                    newStageXY = {x: _baseStagePos.x, y: _baseStagePos.y - _elm.parentRect.height};
                    break;
                case 1:
                    newStageXY = {x: _baseStagePos.x + _elm.parentRect.width, y: _baseStagePos.y};
                    break;
                case 2:
                    newStageXY = {x: _baseStagePos.x, y: _baseStagePos.y + _elm.parentRect.height};
                    break;
                case 3:
                    newStageXY = {x: _baseStagePos.x - _elm.parentRect.width, y: _baseStagePos.y};
                    break;
            }

            _timerId = setInterval(
                /**
                 * stageの終点座標との距離を得る。今回の移動距離を算出。移動。
                 * もし終点座標との距離が閾値よりも小さければ、stageを終点座標まで移動し、timerクリア。
                */
                function() {
                    let nowStageElmXY = getRelPos(_elm.stage, _elm.parent);

                    if (Math.abs(nowStageElmXY.x - newStageXY.x) < 10 && Math.abs(nowStageElmXY.y - newStageXY.y) < 10) {
                        clearInterval(_timerId);
                        _elm.stage.style.left = newStageXY.x + "px";
                        _elm.stage.style.top  = newStageXY.y + "px";
                        _currentImageIdx = Math.abs(_currentImageIdx - 1);
                        _status.swipeDirection = undefined;
                        _status.nextImagePlace = undefined;
                        _status.isAnimating = false;
                    }
                    else {
                        _elm.stage.style.left = (newStageXY.x + nowStageElmXY.x) / 2 + "px";
                        _elm.stage.style.top  = (newStageXY.y + nowStageElmXY.y) / 2 + "px";
                    }
                },
                30
            );
        }



        /**
         * 写真のURLを返す
         * 年、丁内番号を受取りimgタグのsrcに設定するURLを返す。
        */
        function getPhotoURL(year, chonai) {
            const BASEYEAR = 2019;
            const BASEURL = "https://www.kakudate.com/omatsuri/ningyou/mobile/touch/img/";
            const photoInfo = [
                ["yamane.jpg","yokomachi2.jpg","sakura.jpg","kamishin.jpg","nanoka.jpg","nishikatsu2.jpg","chuo.jpg","honcho2.jpg","shimoiwase.jpg","sugazawa3.jpg","tobu.jpg","ekidori.jpg","ekimae.jpg","iwase.jpg","otsuka2.jpg","seibu.jpg","hokubu.jpg","kawara.jpg","shinmeisya.jpg"],	// 2019 R1
                ["yamane2.jpg","yokomachi.jpg","sakuramicho.jpg","kamishinmachi.jpg","nanokamachi","","","honcho.jpg","shimoiwasemachi.jpg","","","ekidori.jpg","","","ootsuka.jpg","","hokubu.jpg","kawaramachi.jpg","IMG20210909103752.jpg"],	// 2021 R3
                ["yamane.jpg","yokomachi.jpg","sakuramicho2.jpg","kamishinmachi.jpg","nanokamachi.jpg","nishikaturakucho.jpg","chuou.jpg","honcho2.jpg","shimoiwasemachi.jpg","sugazawa.jpg","tobu.jpg","ekidori.jpg","ekimae2.jpg","iwase.jpg","ootsuka2.jpg","seibu.jpg","hokubu.jpg","kawaramachi.jpg","okiyama_shinmeisya.jpg"]	// 2022 R4
            ];

            let url = BASEURL + year + "/" + photoInfo[year - BASEYEAR][chonai];

            return(url);
        }



        /** 
         * 指定した要素の座標を、指定したベース要素からの相対座標で返す。
        */
        function getRelPos(targetElm, baseElm) {
            let targetRect = targetElm.getBoundingClientRect();
            let baseRect = baseElm.getBoundingClientRect();

            return({x: targetRect.left - baseRect.left, y: targetRect.top - baseRect.top});
        }
    </script>
</body>
</html>