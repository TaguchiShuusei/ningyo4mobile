<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>GRAYCODE JavaScript</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            font-size: 14px;
        }
        body {
            position: relative;
        }
        h1 {
            height: 50px;
            margin: 0 1em;
            padding: 0;
            text-align: center;
            font-size: 2em;
        }
        #parent {
            left: 0;
            top: 0;
            position: relative;
            margin: auto;
            height: calc(100% - 50px);
            width: 100%;
            overflow: hidden;
            background-color: #3f98d1;
        }
        #stage {
            position: absolute;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
        /*    border-radius: 75px;*/
            background-color: #cadf14e7;
        }
        .imageContainer {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #ic0 {
            background-color: #df149be7;
            left: 0;
            top: 0;
            z-index: 1;
        }
        #ic1 {
            background-color: #dfba14e7;
            left: 0;
            top: 0;
            z-index: 0;
        }
    </style>
</head>
<body>
    <h1>スマホでスワイプ</h1>
    <section id="parent">
        <div id="stage">
            <div id="ic0" class="imageContainer"></div>
            <div id="ic1" class="imageContainer"></div>
        </div>
    </section>

    <script>
        const THRESHOLD = 3;
        // HTML要素関連変数
        let _elm = {
            parent: document.getElementById("parent"),  // #parent要素
            stage: document.getElementById("stage"),    // #stage要素
            images: [document.getElementById("ic0"), document.getElementById("ic1")],
            parentRect: null
        };
        _elm.parentRect = _elm.parent.getBoundingClientRect();
        
        // status管理関連変数
        let _status = {
            isTouching: false,  // touchstart しているか
            isSwiping: false,   // スワイプしているか
            isAnimating: false, // 自動的に移動中か
            swipeDirection: undefined,
            nextImagePlace: undefined   // 0, 1, 2, 3
        };

        let _touchStartPos = {x: null, y: null};
        let _touchEndPos = {x: null, y: null};
        let _currentImageIdx = 0;   // 現在表示されているimage要素を示す (#ic0 / #ic1)
        let _stageBasePos = {x: null, y: null};  // stage要素のスワイプしていない場合座標
        let _startStagePos = {x: null, y: null}; // touchstart時のstage要素の座標
        let _baseStagePos = {x: null, y: null};  // 基準となるstageの座標（アニメーションの終了位置を求めるのに使用） 
        let _timerId = undefined;    // animationのsetInterval()が返すタイマーID

        let _image = {width: 0, height: 0};
        {
            // imageBoxのwidth, heightを_imageオブジェクトに保存
            let bound = _elm.images[0].getBoundingClientRect();
            _image = {width: bound.width, height: bound.height};
        }


        
        // タッチ開始
        _elm.stage.addEventListener('touchstart', onSwipeStart);
        // スワイプ／フリック
        _elm.stage.addEventListener('touchmove', onSwipe);
        // タッチ終了
        _elm.stage.addEventListener('touchend', onSwipeEnd);




        function onSwipeStart(event) {
            event.preventDefault();

            _startStagePos = getRelPos(_elm.stage, _elm.parent);     // stage要素の親要素からの相対座標を保存

            if (_status.isAnimating) {
                clearInterval(_timerId);    // animationを止める
                _status.isAnimating = false;
                _status.isSwiping = true;
            }
            else {
                _baseStagePos = _startStagePos;
            }
            _status.isTouching = true;
            _touchStartPos = {clientX: event.touches[0].clientX, clientY: event.touches[0].clientY};    // 座標系はなんでもいい
        }



        function onSwipe(event) {
            if (! _status.isTouching)
                return;

            event.preventDefault();

            // スワイプ開始の判定
            // 　スワイプの方向の判定は、指の移動距離が閾値を超えた時を持って行う。
            // 　方向が決まったら、_status.isSwiping, _status.swipeDirection が設定される。
            {
                if (_status.isSwiping == false) {
                    let deltaX = event.touches[0].clientX - _touchStartPos.clientX;
                    let deltaY = event.touches[0].clientY - _touchStartPos.clientY;
                    // 閾値を超えたらスワイプの方向を判定する。
                    if (Math.max(Math.abs(deltaX), Math.abs(deltaY)) < THRESHOLD)
                        return;

                    if (Math.abs(deltaX) >= Math.abs(deltaY)) {
                        _status.swipeDirection = deltaX >= 0 ? 1 : 3;
                    }
                    else {
                        _status.swipeDirection = deltaY >= 0 ? 2 : 0;
                    }
                    _status.isSwiping = true;
                }
            }


            // stage要素をスワイプで移動
            // 　これによりstage上の2つのimageBoxが移動する。
            {
                if (_status.swipeDirection == 1 || _status.swipeDirection == 3) {
                    _elm.stage.style.left = _startStagePos.x + (event.touches[0].clientX - _touchStartPos.clientX) + "px";
                }
                else {
                    _elm.stage.style.top  = _startStagePos.y + (event.touches[0].clientY - _touchStartPos.clientY) + "px";
                }
            }


            // imageBoxの移動によってスキマのできる側が変わった時、次の画像のimageBoxを再配置
            {
                let imagePos = getRelPos(_elm.images[_currentImageIdx], _elm.parent);
                if (_status.swipeDirection == 1 || _status.swipeDirection == 3) {
                    if (imagePos.x >= 0) {
                        if (_status.nextImagePlace != 3) {
                            replaceNextImage(3);
                            _status.swipeDirection = 1;
                        }
                    }
                    else {
                        if (_status.nextImagePlace != 1) {
                           replaceNextImage(1);
                           _status.swipeDirection = 3;
                        }
                    }
                }
                else {
                    if (imagePos.y >= 0) {
                        if (_status.nextImagePlace != 0) {
                            replaceNextImage(0);
                            _status.swipeDirection = 2;
                        }
                    }
                    else {
                        if (_status.nextImagePlace != 2) {
                            replaceNextImage(2);
                            _status.swipeDirection = 0;
                        }
                    }
                }
            }
        }



        function onSwipeEnd(event) {
            event.preventDefault();
            _status.isTouching = false;
            _status.isSwiping = false;
            animateStage(_status.swipeDirection);
        }



        // stageをスワイプした事でできたスキマを埋めるようにもう一つのイメージBoxを移動
        function replaceNextImage(place) {
            console.log("replaceNextImage(" + place + ")");
            
            let currentImageElm = _elm.images[_currentImageIdx];
            let nextImageElm = _elm.images[Math.abs(_currentImageIdx - 1)];

            let currentImagePos = getRelPos(currentImageElm, _elm.stage);   // stage座標

            switch (place) {
                case 0:
                    nextImageElm.style.top =  (currentImagePos.y - _image.height) + "px";
                    nextImageElm.style.left = (currentImagePos.x) + "px";
                    break;
                case 1:
                    nextImageElm.style.top =  (currentImagePos.y) + "px";
                    nextImageElm.style.left = (currentImagePos.x + _image.width) + "px";
                    break;
                case 2:
                    nextImageElm.style.top =  (currentImagePos.y + _image.height) + "px";
                    nextImageElm.style.left = (currentImagePos.x) + "px";
                    break;
                case 3:
                    nextImageElm.style.top =  (currentImagePos.y) + "px";
                    nextImageElm.style.left = (currentImagePos.x - _image.width) + "px";
                    break;
            }
            _status.nextImagePlace = place;

            currentImageElm.style.zIndex = 0;
            nextImageElm.style.zIndex = 10;
        }



        /**
         * touchend（指が離れて）から、次の画像が定位置に来るようにstageをアニメーション移動する。
        */
        function animateStage(direction) {
            _status.isAnimating = true;

            console.log("animateStage(" + direction + ")");
            
            // スワイプ前のstage座標(_baseStagePos)と、directionからstageの終点座標を求める。
            let newStageXY;

            switch (direction) {
                case 0:
                    newStageXY = {x: _baseStagePos.x, y: _baseStagePos.y - _elm.parentRect.height};
                    break;
                case 1:
                    newStageXY = {x: _baseStagePos.x + _elm.parentRect.width, y: _baseStagePos.y};
                    break;
                case 2:
                    newStageXY = {x: _baseStagePos.x, y: _baseStagePos.y + _elm.parentRect.height};
                    break;
                case 3:
                    newStageXY = {x: _baseStagePos.x - _elm.parentRect.width, y: _baseStagePos.y};
                    break;
            }

            _timerId = setInterval(
                /**
                 * stageの終点座標との距離を得る。今回の移動距離を算出。移動。
                 * もし終点座標との距離が閾値よりも小さければ、stageを終点座標まで移動し、timerクリア。
                */
                function() {
                    let nowStageElmXY = getRelPos(_elm.stage, _elm.parent);

                    if (Math.abs(nowStageElmXY.x - newStageXY.x) < 10 && Math.abs(nowStageElmXY.y - newStageXY.y) < 10) {
                        clearInterval(_timerId);
                        _elm.stage.style.left = newStageXY.x + "px";
                        _elm.stage.style.top  = newStageXY.y + "px";
                        _currentImageIdx = Math.abs(_currentImageIdx - 1);
                        _status.swipeDirection = undefined;
                        _status.nextImagePlace = undefined;
                        _status.isAnimating = false;
                    }
                    else {
                        _elm.stage.style.left = (newStageXY.x + nowStageElmXY.x) / 2 + "px";
                        _elm.stage.style.top  = (newStageXY.y + nowStageElmXY.y) / 2 + "px";
                    }
                },
                30
            );
        }



        /** 
         * 指定した要素の座標を、指定したベース要素からの相対座標を返す
        */
        function getRelPos(targetElm, baseElm) {
            let targetRect = targetElm.getBoundingClientRect();
            let baseRect = baseElm.getBoundingClientRect();

            return({x: targetRect.left - baseRect.left, y: targetRect.top - baseRect.top});
        }
    </script>
</body>
</html>